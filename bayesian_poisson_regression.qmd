# Bayesian Poisson Regression 
## Vergleich von Normal und Poisson Verteilung

:::: {.columns}

::: {.column width='45%'}
Die ***Poissonverteilung*** ist eine diskrete Wahrscheinlichkeitsverteilung, die die Anzahl der Ereignisse modelliert, die in einem festen Zeitraum oder in einem festen Intervall auftreten. Die Poissonverteilung hat nur einen Parameter, $\lambda$, der die durchschnittliche Anzahl der Ereignisse pro Intervall angibt. Die Wahrscheinlichkeitsfunktion der Poissonverteilung ist gegeben durch

$$
P_\lambda(x)=\frac{\lambda^x}{x!} \mathrm{e}^{-\lambda}
$$

```{ojs}
//| echo: false
jstat = require('jstat')
import {Plot} from "@mkfreeman/plot-tooltip"
poispdf = {
  const x = d3.range(0, params[0] + 4*Math.sqrt(params[0]), 1);
  const data = x.map(x => ({x: x, pdf: jstat.poisson.pdf(x, params[0])}));
  return data
}
poiscdf = jstat.poisson.cdf(params[1], params[0]);
viewof params = Inputs.form([
      Inputs.range([0.1, 20], {value: 2, step: 0.1, label: tex`\lambda:`})
    ])
```

```{ojs}
//| echo: false
moments = tex`
\begin{aligned}
&\mathrm{E}( X) =  \lambda = ${params[0].toPrecision(3)} \\[0.5em]
&\mathrm{Var}( X) =  \lambda  = ${params[0].toPrecision(3)} 
\end{aligned}
`
```

```{ojs}
//| echo: false
plt_pdf = Plot.plot({
    color: { 
      legend: false
    },
    x: {
      label: "x",
      axis: true
    },
    y: {
      label: "f(x)",
      axis: true
    },
  tooltip: {
    fill: "#1bbc9d",
    stroke: "#1bbc9d",
    opacity: 1,
  },
    marks: [
      Plot.ruleY([0]),
      Plot.barY(poispdf,{x: "x", y: "pdf", fill: "#1bbc9d", strokeWidth: 0, opacity: 1,
                title: (d) => `P(X=${d.x}) = ${(d.pdf).toPrecision(4)}`})
    ]
  })
```

:::

::: {.column width='10%'}

:::

::: {.column width='45%'}
Die ***Normalverteilung*** ist eine kontinuierliche Wahrscheinlichkeitsverteilung, die die Addition unendlich vieler gleicher unabh√§ngiger Verteilungen modelliert. Die Normalverteilung hat zwei Parameter, den Erwartungswert $\mu$ und die Standardabweichung $\sigma$. Die Wahrscheinlichkeitsfunktion der Normalverteilung ist gegeben durch

$$
f(x) = \frac{1}{\sigma \sqrt{2\pi}} e^{-\frac{1}{2} \left(\frac{x-\mu}{\sigma}\right)^2}
$$

```{ojs}
//| echo: false
viewof mu = Inputs.range([-3, 3], {
  label: tex`\mu`,
  value: 0
})

viewof sigma = Inputs.range([1e-2, 2], {
  label: tex`\sigma`,
  value: 0.4
})

html`<style>
input[type="range"] {
  /* Change the slider track color */
  -webkit-appearance: none;
  width: 100%;
  height: 8px;
  background: #1bbc9d50;
  border-radius: 5px;
  outline: none;
  opacity: 0.7;
  transition: opacity .15s ease-in-out;
}

input[type="range"]::-webkit-slider-thumb {
  /* Change the slider thumb color */
  -webkit-appearance: none;
  appearance: none;
  width: 15px;
  height: 15px;
  border-radius: 50%;
  background: #1bbc9d;
  cursor: pointer;
}
</style>`
```


```{ojs}
//| echo: false
chart = {
  const svg = d3.create("svg").attr("width", width).attr("height", height);

  const xAxis = svg
    .append("g")
    .attr("transform", `translate(0, ${yScale(0)})`)
    .call(d3.axisBottom(xScale));

  const yAxis = svg
    .append("g")
    .attr("transform", `translate(${xScale(0)}, 0)`)
    .call(d3.axisLeft(yScale));

  const path = svg
    .append("g")
    .append("path")
    .attr("d", line(data))
    .attr("fill", "none")
    .attr("stroke", "#1bbc9d");

  return svg.node();
}
```


```{ojs}
//| echo: false
line = d3
  .line()
  .x((d) => xScale(d.x))
  .y((d) => yScale(d.y))
  
yExtent = [0, Math.max(1, normalPdf(0, 0, sigma))]

data = x.map((x) => ({
  x: x,
  y: normalPdf(x, mu, sigma)
}))

x = d3
  .range(numXPoints)
  .map((i) => xExtent[0] + (i * (xExtent[1] - xExtent[0])) / (numXPoints - 1))
  
  yScale = d3
  .scaleLinear()
  .domain(yExtent)
  .range([height - margin.bottom, margin.top])
  
  xScale = d3
  .scaleLinear()
  .domain(xExtent)
  .range([margin.left, width - margin.right])
  
  xExtent = [Math.min(-3, mu - 3 * sigma), Math.max(3, mu + 3 * sigma)]
  
  margin = ({ top: 40, right: 40, bottom: 40, left: 40 })
  
  numXPoints = width / 2
  
  normalPdf = function (x, mu, sigma) {
  return (
    (1 / (sigma * Math.sqrt(2 * Math.PI))) *
    Math.exp((-0.5 * Math.pow(x - mu, 2)) / (2 * Math.pow(sigma, 2)))
  );
}

width = 350
height = 350
```



:::

::::


