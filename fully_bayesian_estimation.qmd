# The (Fully) Bayesian Estimation Approach
Im Gegensatz zum Bayes Factor werden im sogenannten Fully Bayesian Estimation Aproach keine Hypothesen gegeneinander abgewogen, sondern die Posterioriverteilung von Parametern direkt geschätzt. Hierzu wird nach dem Bayes Theorem die Likelihood-Funktion mit einer Prior-Verteilung multipliziert, um die Posterior-Verteilung zu erhalten. Diese wird dann durch eine Monte-Carlo-Simulation approximiert. Der Fully Bayesian Estimation Aproach ist in der Regel rechenintensiver als der Bayes Factor, da die Posterior-Verteilung für jeden Parameter geschätzt werden muss. Der Fully Bayesian Estimation Aproach ist jedoch flexibler und erlaubt es, die Unsicherheit in den Schätzungen direkt zu quantifizieren.  
Diesem komplexen Verfahren nähern wir uns nun Schritt für Schritt - zunächst auf konzeptueller Ebene mit folgendem Experiment:

::: {.panel-tabset}

## Experiment {{< iconify fa6-solid dice >}}

:::: {.columns}

::: {.column width='45%'}
[Zeichnet auf ein Schmierblatt einen Zahlenstrahl von 0 bis 1. Ich werde auf einem Glücksrad einen bestimmten Anteil als »Pro G9« kennzeichnen und den Rest als »Pro G8« - ihr wisst aber nicht wie groß welcher Anteil ist. Ihr könnt nur beobachten, wie oft das Glücksrad auf »Pro G9« und »Pro G8« landet. Nach jedem Drehen des Glücksrads, tragt ihr in den Zahlenstrahl ein, auf welchen Abschnitt ihr 1€ setzen würdet, angenommen wir spielen das folgende Spiel:]{style="color: #1bbc9d; font-size: .85em;"}

> [»Wenn ihr falsch liegt, bekomme ich 1€, wenn ihr richtig liegt bekommt ihr $\frac{1}{\text{Länge eures Abschnitts}}$€«.]{style="color: #1bbc9d; font-size: .85em;"}
:::

::: {.column width='10%'}

:::

::: {.column width='45%'}
![](img/Elicitation.png){}
:::

::::

## Interpretation der Ergebnisse {{< iconify fa6-solid chart-line >}}

::: 

## Interaktive Visualisierung
Der folgenden interaktiven Visualisierung ist als Prior eine Betaverteilung und als Likelihood eine Binomialverteilung vorgegeben. Wendet man Bayes Theorem auf die entsprechenden Funktionsvorschriften an kann man zeigen, dass als Posterior wieder eine Betaverteilung entsteht. Diesen seltenen Fall der analytischen (»geschlossenen«) Lösbarkeit nennt man conjugacy prior [@lambert2018].

::: {.panel-tabset}

## Aufgabe {{< iconify fa6-solid person-digging >}}
Probiert aus, was in der folgenden interaktiven Visualisierung mit dem Posterior passiert,

* wenn ein flacher Prior gewählt ist, der Anteil der G9-Befürworter:innen gleich bleibt, aber die Anzahl der Beobachtungen steigen (also z.B. n₁ = 2 & n₂ = 4; n₁ = 5 & n₂ = 10; n₁ = 23 & n₂ = 46; ...)
* wenn ein präziser Prior gewählt ist, und die Anzahl der Beobachtungen klein ist
* wenn ein präziser Prior gewählt ist, dessen Mittelwert »weit« vom Anteil der G9-Befürworter:innen entfernt ist und die Anzahl der Beobachtungen steigen


## Lösungsvorschlag {{< iconify fa6-solid lightbulb >}}
* Der Posterior ist vollständig durch die Daten getrieben. Der Modus des Posteriors ist gleich dem Anteil der G9-Befürworter:innen. Mit steigender Anzahl der Beobachtungen wird der Posterior schmaler, das HDI kleiner.
* Der Posterior ist recht stark durch den Prior geprägt. 
* Mit steigender Anzahl der Beobachtungen sinkt der Einfluss des Priors.

:::

```{shinylive-r}
#| standalone: true
#| viewerHeight: 800

library(bslib)
ui <- page_fluid(
  theme = bs_theme(
    # Controls the default grayscale palette
   # bg = "#1bbc9d30",
   # fg = "#B8BCC2",
    "bg-dark" = "#1bbc9d50",
    # Controls the accent (e.g., hyperlink, button, etc) colors
    primary = "#1bbc9d",
    secondary = "#1bbc9d",
    "input-border-color" = "#1bbc9d"
  ),
  h5(""),
  layout_column_wrap(
    card(card_header(class = "bg-dark", "Prior"),
         card_body(
           sliderInput(
             "prior_mu",
             "Prior Mean",
             min = 0,
             max = 1,
             value = .5,
             step = .01
           ),
           sliderInput(
             "prior_phi",
             "Prior Precision",
             min = 2,
             max = 100,
             value = 3,
             step = 1
           )
         )),
    card(card_header(class = "bg-dark", "Data"),
         card_body(
           numericInput(
             "successes",
             "n₁ = Zustimmung G9",
             min = 0,
             value = 13,
             step = 1
           ),
           numericInput(
             "failures",
             "n₂ = Ablehnung G9",
             min = 0,
             value = 8,
             step = 1
           )
         ), full_screen = T)), 
  card(card_header("Posterior", class = "bg-dark"),
       card_body(plotOutput("plot")))
)


server <- function(input, output, session) {
  
### custom functions ###########################################################
# muphi_to_shapes 
muphi_to_shapes <- function(mu, phi) {
  shape1 <- mu * phi
  shape2 <- (1 - mu) * phi
  return(list(shape1 = shape1, shape2 = shape2))
}

### aux variables ##############################################################
# convert prior parameterization

prior_shapes <- reactive({
  muphi_to_shapes(input$prior_mu, input$prior_phi)
})

### plot #######################################################################
output$plot <- renderPlot({
  
  # set x-axis
  p <- seq(0,1, length=1000)
  
  # compute max-desity for ylim and legend position
  density_max <-
    max(c(
      dbeta(p,
            prior_shapes()$shape1,
            prior_shapes()$shape2),
      dbeta(
        p,
        prior_shapes()$shape1 + input$successes,
        prior_shapes()$shape2 + input$failures
      )
    ))
  
  # compute lower bound of 96%-HPDI
  hpdi_lb <-
    qbeta(.02,
           prior_shapes()$shape1 + input$successes,
          prior_shapes()$shape2 + input$failures)
  # compute upper bound of 96%-HPDI
  hpdi_ub <-
    qbeta(.98,
          prior_shapes()$shape1 + input$successes,
          prior_shapes()$shape2 + input$failures)
  
  # create plot
  plot(
    p,
    dbeta(p,
          prior_shapes()$shape1,
          prior_shapes()$shape2),
    type = 'l',
    col = "#1bbc9d",
    ylab = "Wahrscheinlichkeitsdichte",
    xlab = "Anteil G9-Befürworter:innen",
    frame.plot = F,
    ylim = c(0, density_max)
    )
  lines(p,
        dbeta(
          p,
          prior_shapes()$shape1 + input$successes,
          prior_shapes()$shape2 + input$failures
          ),
          col = '#EA80FC'
        )
  polygon(c(hpdi_lb, hpdi_lb, hpdi_ub, hpdi_ub),
          c(0, density_max/40, density_max/40, 0),
          col = "#EA80FC30",
          border = "#EA80FC00")
  legend(
    bty = "n",
    .8,
    density_max,
    c('Prior', 'Posterior', '96% HDI'),
    lty = c(1, 1, 1),
    lwd = c(1, 1, 8),
    col = c('#1bbc9d', '#EA80FC', '#EA80FC30')
  )

})

### debug ######################################################################
# output$debug <- renderPrint({
#   max(c(
#                dbeta(p, 
#                      prior_shapes()$shape1, 
#                      prior_shapes()$shape2),
#                dbeta(p, 
#                      prior_shapes()$shape1 + input$successes, 
#                      prior_shapes()$shape2 + input$failures))
#              )
#              
# })

}

shinyApp(ui = ui, server = server)
```